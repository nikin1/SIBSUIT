Министерство цифрового развития, связи и массовых коммуникаций Российской Федерации
ФГБОУ ВО «СибГУТИ»


Кафедра ТСиВС
Отчет по курсовой работе
вариант-25
Умножение дат



Выполнил студент: Шаповал Н.О.
                                         				      группы: ИА-131

                                                             Проверил преподаватель:
											Лебеденко Л.Ф
                                      	



Отчёт принят ____________________________
                                      Дата, подпись преподавателя

Работа зачтена ____________________________
                                     Оценка, дата, подпись преподавателя






Задание

В 1928 г. были четыре даты, обладающие замечательным свойством: при записи их обычным образом произведение числа на месяц дает год. Вот эти даты: 28/1 — 28, 14/2 — 28, 7/4 — 28 и 4/7 — 28. Сколько раз в нашем веке (с 1901 по 2000 г. включительно) встречаются такие даты? Может быть, вы попытаетесь найти год нашего столетия, в котором число таких дат максимально? Существует лишь один такой год. Записать в файл все найденные даты.  Разработать функцию, определяющую  обладает ли  дата заданным свойствам.




Анализ задачи

Чтобы узнать, сколько раз встречаются данные даты, нам нужно сделать перебор всего чисел. Для этого используем 3 вложенных цикла. Сначала перебираем год, в каждом году месяца, в каждом месяце дни. Количество дней изменяется между 30 и 31 днями а также 29 или 28 дней в феврале.

Далее нужно будет сравнить, подходит ли число. Для этого умножаем день и месяц. И если данное число равно двум последним цифрам в году, то дата имеет нужно нам свойство.




Тестовые данные

В моем задании практически не нужны текстовые данные, т.к. я осуществляю перебор всех значений(всех дат), и соответсвенно пользователю это вводить не нужно. Однако пользователь вводит назнавание файла, куда нужно помещаются даты, поэтому стоит сделать проверку на количетсво аргументов, подаваемых в функцию. 
Также еще реализуется функция, в к-ую в качестве аргументов мещается дата, а по выводу можно оченить, подходит ли нам эта дата. Для этой функции я написал 2 примера, 01.05.1905 (пример подходит),  01.05.1906(пример не подходит).



Листинг программы


Всю программу я разделил на 2 файла. В первом находятся 2 функции, во втором функция main

Содержание 1 файла

#include <stdio.h>

int search_dates(char *file_name, int *max_year) {
int cnt = 0, max_cnt_year = 0;
int days;
FILE *fp;
fp = fopen(file_name, "w");

for (int year = 1901; year <= 2000; year++) {
int year_tmp = year % 100;
int cnt_year = 0;

for (int month = 1; month <= 12; month++) {
if (month == 1 || month == 3 || month == 5 || month == 7
|| month == 8 || month == 10 || month == 12) {
days = 31;
} else if (month == 2) {
if (month % 4 == 0) days = 29;
else days = 28;
} else {
days = 30;
}
for (int day = 1; day < days; day++) {
if (day * month == year_tmp) {
cnt++;
cnt_year++;

fprintf(fp, "%02d.%02d.%d\n", day, month, year);
}
}
}

// поиск года с макисмальным количеством таких дат
if (cnt_year > max_cnt_year) {
max_cnt_year = cnt_year;
*max_year = year;
}

}
fclose(fp);
return cnt;
}

int check_date(int day, int month, int year) {
if (day * month == (year % 100)) return 0;
else return 1; 
}



Содержание файла с функцией main:

#include <stdio.h>

int search_dates(char *file_name, int *max_year);
int check_date(int day, int month, int year);

int main(int argc, char* argv[]) {

if (argc != 2) {
printf("Введите 1 аргумент для создания файла\n");
} else {
int max;
int cnt = search_dates(argv[1], &max);
printf("Количество дат: %d\n", cnt);
printf("Год, в к-ом число таких дат максимально: %d\n", max); 

int day = 1, month = 5, year = 1905;
printf("\nПроверка числа %02d.%02d.%d\n", day, month, year);

if (check_date(day, month, year) == 0) printf("Данное число подходит\n");
else printf("Данное число не подходит\n");


day = 1, month = 5, year = 1906;
printf("\nПроверка числа %02d.%02d.%d\n", day, month, year);

if (check_date(day, month, year) == 0) printf("Данное число подходит\n");
else printf("Данное число не подходит\n");

}

return 0;
}


